/**
 * Generated by orval v6.20.0 🍺
 * Do not edit manually.
 * Cat API
 * ![image](https://s3-us-west-2.amazonaws.com/tdapi-live/static/tie-square-135.png)

## An open, free, read & write API all about Dogs
The Cat API gives you access to 1000's of dog images, and breeds.
- Upload your own images
- Detailed info on all the Breeds
- Favourite or Vote on images
- Get stats on your requests
- Save a custom value with each request

## How is this free?
Our goal is to create free, fun & useful public service API's, helping people learn to code, create awesome projects, and be a stable fixture in a turbulent world.

## How do i get access?
Just signup for an API Key from https://thecatapi.com for free. We're looking forward to seeing what you build!
 * OpenAPI spec version: 1.6.1
 */
import {useMutation, useQuery} from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
import type {
  GetBreeds200,
  GetBreedsBreedId200,
  GetBreedsBreedIdFacts200,
  GetBreedsBreedIdFactsParams,
  GetBreedsParams,
  GetBreedsSearch200,
  GetBreedsSearchParams,
  GetFacts200,
  GetFavourites200,
  GetImages200,
  GetImagesBkIEhN3pG200,
  GetImagesParams,
  GetImagesSearch200,
  GetImagesSearch401,
  GetImagesSearchParams,
  GetVotes200,
  PostFavourites200,
  PostFavouritesBody,
  PostImagesImageIdBreedsBody,
  PostImagesUpload201,
  PostImagesUploadBody,
  PostVotes201,
  PostVotesBody,
  PostWebhooks200,
  PostWebhooksBody,
} from "./schemas";
import {customInstance} from "./utils/custom-instance";
import type {ErrorType, BodyType} from "./utils/custom-instance";

/**
 * Searchs all approved images. Default is to reutrn RANDOM images, but with an API-Key you can use 'order=DESC' or 'order=ASC' along with the 'page' and 'limit' parameters to paginate through them in the order they were approved.

Pagination-Count, Pagination-Page, and Pagination-Limit headers are present in the response so you know the total number of images that can be paginated through for the passed search filters.
 * @summary /images/search
 */
export const getImagesSearch = (params?: GetImagesSearchParams, signal?: AbortSignal) => {
  return customInstance<GetImagesSearch200>({
    url: `/images/search`,
    method: "get",
    params,
    signal,
  });
};

export const getGetImagesSearchQueryKey = (params?: GetImagesSearchParams) => {
  return [`/images/search`, ...(params ? [params] : [])] as const;
};

export const getGetImagesSearchQueryOptions = <
  TData = Awaited<ReturnType<typeof getImagesSearch>>,
  TError = ErrorType<GetImagesSearch401>,
>(
  params?: GetImagesSearchParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImagesSearch>>, TError, TData>>;
  }
) => {
  const {query: queryOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetImagesSearchQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getImagesSearch>>> = ({signal}) =>
    getImagesSearch(params, signal);

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getImagesSearch>>,
    TError,
    TData
  > & {queryKey: QueryKey};
};

export type GetImagesSearchQueryResult = NonNullable<Awaited<ReturnType<typeof getImagesSearch>>>;
export type GetImagesSearchQueryError = ErrorType<GetImagesSearch401>;

/**
 * @summary /images/search
 */
export const useGetImagesSearch = <
  TData = Awaited<ReturnType<typeof getImagesSearch>>,
  TError = ErrorType<GetImagesSearch401>,
>(
  params?: GetImagesSearchParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImagesSearch>>, TError, TData>>;
  }
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetImagesSearchQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get the raw analysis results for any uploaded image
 * @summary /images/:image_id/analysis
 */
export const getImagesBkIEhN3pG = (signal?: AbortSignal) => {
  return customInstance<GetImagesBkIEhN3pG200>({
    url: `/images/BkIEhN3pG`,
    method: "get",
    signal,
  });
};

export const getGetImagesBkIEhN3pGQueryKey = () => {
  return [`/images/BkIEhN3pG`] as const;
};

export const getGetImagesBkIEhN3pGQueryOptions = <
  TData = Awaited<ReturnType<typeof getImagesBkIEhN3pG>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImagesBkIEhN3pG>>, TError, TData>>;
}) => {
  const {query: queryOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetImagesBkIEhN3pGQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getImagesBkIEhN3pG>>> = ({signal}) =>
    getImagesBkIEhN3pG(signal);

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getImagesBkIEhN3pG>>,
    TError,
    TData
  > & {queryKey: QueryKey};
};

export type GetImagesBkIEhN3pGQueryResult = NonNullable<
  Awaited<ReturnType<typeof getImagesBkIEhN3pG>>
>;
export type GetImagesBkIEhN3pGQueryError = ErrorType<unknown>;

/**
 * @summary /images/:image_id/analysis
 */
export const useGetImagesBkIEhN3pG = <
  TData = Awaited<ReturnType<typeof getImagesBkIEhN3pG>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImagesBkIEhN3pG>>, TError, TData>>;
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetImagesBkIEhN3pGQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Only returns images from your account, uploaded via 'api/v1/images/upload'
 * @summary /images/ (Your uploads)
 */
export const getImages = (params?: GetImagesParams, signal?: AbortSignal) => {
  return customInstance<GetImages200>({
    url: `/images/${params?.imageId}`,
    method: "get",
    params,
    signal,
  });
};

export const getGetImagesQueryKey = (params?: GetImagesParams) => {
  return [`/images/`, ...(params ? [params] : [])] as const;
};

export const getGetImagesQueryOptions = <
  TData = Awaited<ReturnType<typeof getImages>>,
  TError = ErrorType<unknown>,
>(
  params?: GetImagesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImages>>, TError, TData>>;
  }
) => {
  const {query: queryOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetImagesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getImages>>> = ({signal}) =>
    getImages(params, signal);

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getImages>>,
    TError,
    TData
  > & {queryKey: QueryKey};
};

export type GetImagesQueryResult = NonNullable<Awaited<ReturnType<typeof getImages>>>;
export type GetImagesQueryError = ErrorType<unknown>;

/**
 * @summary /images/ (Your uploads)
 */
export const useGetImages = <
  TData = Awaited<ReturnType<typeof getImages>>,
  TError = ErrorType<unknown>,
>(
  params?: GetImagesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImages>>, TError, TData>>;
  }
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetImagesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Make sure you're using the right field to send the image, and Content-Type header
 * @summary /images/upload
 */
export const postImagesUpload = (postImagesUploadBody: BodyType<PostImagesUploadBody>) => {
  const formData = new FormData();
  if (postImagesUploadBody.file !== undefined) {
    formData.append("file", postImagesUploadBody.file);
  }
  if (postImagesUploadBody.sub_id !== undefined) {
    formData.append("sub_id", postImagesUploadBody.sub_id);
  }
  if (postImagesUploadBody.breed_ids !== undefined) {
    formData.append("breed_ids", postImagesUploadBody.breed_ids);
  }

  return customInstance<PostImagesUpload201>({
    url: `/images/upload`,
    method: "post",
    headers: {"Content-Type": "multipart/form-data"},
    data: formData,
  });
};

export const getPostImagesUploadMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postImagesUpload>>,
    TError,
    {data: BodyType<PostImagesUploadBody>},
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postImagesUpload>>,
  TError,
  {data: BodyType<PostImagesUploadBody>},
  TContext
> => {
  const {mutation: mutationOptions} = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postImagesUpload>>,
    {data: BodyType<PostImagesUploadBody>}
  > = (props) => {
    const {data} = props ?? {};

    return postImagesUpload(data);
  };

  return {mutationFn, ...mutationOptions};
};

export type PostImagesUploadMutationResult = NonNullable<
  Awaited<ReturnType<typeof postImagesUpload>>
>;
export type PostImagesUploadMutationBody = BodyType<PostImagesUploadBody>;
export type PostImagesUploadMutationError = ErrorType<unknown>;

/**
 * @summary /images/upload
 */
export const usePostImagesUpload = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postImagesUpload>>,
    TError,
    {data: BodyType<PostImagesUploadBody>},
    TContext
  >;
}) => {
  const mutationOptions = getPostImagesUploadMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary /images/:image_id
 */
export const deleteImagesImageId = (imageId: string) => {
  return customInstance<unknown>({
    url: `/images/${imageId}`,
    method: "delete",
  });
};

export const getDeleteImagesImageIdMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteImagesImageId>>,
    TError,
    {imageId: string},
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteImagesImageId>>,
  TError,
  {imageId: string},
  TContext
> => {
  const {mutation: mutationOptions} = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteImagesImageId>>,
    {imageId: string}
  > = (props) => {
    const {imageId} = props ?? {};

    return deleteImagesImageId(imageId);
  };

  return {mutationFn, ...mutationOptions};
};

export type DeleteImagesImageIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteImagesImageId>>
>;

export type DeleteImagesImageIdMutationError = ErrorType<unknown>;

/**
 * @summary /images/:image_id
 */
export const useDeleteImagesImageId = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteImagesImageId>>,
    TError,
    {imageId: string},
    TContext
  >;
}) => {
  const mutationOptions = getDeleteImagesImageIdMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary /images/:image_id/breeds
 */
export const getImagesImageIdBreeds = (imageId: string, signal?: AbortSignal) => {
  return customInstance<unknown>({
    url: `/images/${imageId}/breeds`,
    method: "get",
    signal,
  });
};

export const getGetImagesImageIdBreedsQueryKey = (imageId: string) => {
  return [`/images/${imageId}/breeds`] as const;
};

export const getGetImagesImageIdBreedsQueryOptions = <
  TData = Awaited<ReturnType<typeof getImagesImageIdBreeds>>,
  TError = ErrorType<unknown>,
>(
  imageId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getImagesImageIdBreeds>>, TError, TData>
    >;
  }
) => {
  const {query: queryOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetImagesImageIdBreedsQueryKey(imageId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getImagesImageIdBreeds>>> = ({signal}) =>
    getImagesImageIdBreeds(imageId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!imageId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getImagesImageIdBreeds>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetImagesImageIdBreedsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getImagesImageIdBreeds>>
>;
export type GetImagesImageIdBreedsQueryError = ErrorType<unknown>;

/**
 * @summary /images/:image_id/breeds
 */
export const useGetImagesImageIdBreeds = <
  TData = Awaited<ReturnType<typeof getImagesImageIdBreeds>>,
  TError = ErrorType<unknown>,
>(
  imageId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getImagesImageIdBreeds>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetImagesImageIdBreedsQueryOptions(imageId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary /images/:image_id/breeds
 */
export const postImagesImageIdBreeds = (
  imageId: string,
  postImagesImageIdBreedsBody: BodyType<PostImagesImageIdBreedsBody>
) => {
  return customInstance<unknown>({
    url: `/images/${imageId}/breeds`,
    method: "post",
    headers: {"Content-Type": "application/json"},
    data: postImagesImageIdBreedsBody,
  });
};

export const getPostImagesImageIdBreedsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postImagesImageIdBreeds>>,
    TError,
    {imageId: string; data: BodyType<PostImagesImageIdBreedsBody>},
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postImagesImageIdBreeds>>,
  TError,
  {imageId: string; data: BodyType<PostImagesImageIdBreedsBody>},
  TContext
> => {
  const {mutation: mutationOptions} = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postImagesImageIdBreeds>>,
    {imageId: string; data: BodyType<PostImagesImageIdBreedsBody>}
  > = (props) => {
    const {imageId, data} = props ?? {};

    return postImagesImageIdBreeds(imageId, data);
  };

  return {mutationFn, ...mutationOptions};
};

export type PostImagesImageIdBreedsMutationResult = NonNullable<
  Awaited<ReturnType<typeof postImagesImageIdBreeds>>
>;
export type PostImagesImageIdBreedsMutationBody = BodyType<PostImagesImageIdBreedsBody>;
export type PostImagesImageIdBreedsMutationError = ErrorType<unknown>;

/**
 * @summary /images/:image_id/breeds
 */
export const usePostImagesImageIdBreeds = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postImagesImageIdBreeds>>,
    TError,
    {imageId: string; data: BodyType<PostImagesImageIdBreedsBody>},
    TContext
  >;
}) => {
  const mutationOptions = getPostImagesImageIdBreedsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary /images/:image_id/breeds/:breed_id
 */
export const deleteImagesImageIdBreedsBreedId = (imageId: string, breedId: string) => {
  return customInstance<unknown>({
    url: `/images/${imageId}/breeds/${breedId}`,
    method: "delete",
  });
};

export const getDeleteImagesImageIdBreedsBreedIdMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteImagesImageIdBreedsBreedId>>,
    TError,
    {imageId: string; breedId: string},
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteImagesImageIdBreedsBreedId>>,
  TError,
  {imageId: string; breedId: string},
  TContext
> => {
  const {mutation: mutationOptions} = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteImagesImageIdBreedsBreedId>>,
    {imageId: string; breedId: string}
  > = (props) => {
    const {imageId, breedId} = props ?? {};

    return deleteImagesImageIdBreedsBreedId(imageId, breedId);
  };

  return {mutationFn, ...mutationOptions};
};

export type DeleteImagesImageIdBreedsBreedIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteImagesImageIdBreedsBreedId>>
>;

export type DeleteImagesImageIdBreedsBreedIdMutationError = ErrorType<unknown>;

/**
 * @summary /images/:image_id/breeds/:breed_id
 */
export const useDeleteImagesImageIdBreedsBreedId = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteImagesImageIdBreedsBreedId>>,
    TError,
    {imageId: string; breedId: string},
    TContext
  >;
}) => {
  const mutationOptions = getDeleteImagesImageIdBreedsBreedIdMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary /breeds
 */
export const getBreeds = (params?: GetBreedsParams, signal?: AbortSignal) => {
  return customInstance<GetBreeds200>({
    url: `/breeds`,
    method: "get",
    params,
    signal,
  });
};

export const getGetBreedsQueryKey = (params?: GetBreedsParams) => {
  return [`/breeds`, ...(params ? [params] : [])] as const;
};

export const getGetBreedsQueryOptions = <
  TData = Awaited<ReturnType<typeof getBreeds>>,
  TError = ErrorType<unknown>,
>(
  params?: GetBreedsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBreeds>>, TError, TData>>;
  }
) => {
  const {query: queryOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBreedsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBreeds>>> = ({signal}) =>
    getBreeds(params, signal);

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getBreeds>>,
    TError,
    TData
  > & {queryKey: QueryKey};
};

export type GetBreedsQueryResult = NonNullable<Awaited<ReturnType<typeof getBreeds>>>;
export type GetBreedsQueryError = ErrorType<unknown>;

/**
 * @summary /breeds
 */
export const useGetBreeds = <
  TData = Awaited<ReturnType<typeof getBreeds>>,
  TError = ErrorType<unknown>,
>(
  params?: GetBreedsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBreeds>>, TError, TData>>;
  }
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetBreedsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary /breeds/:breed_id
 */
export const getBreedsBreedId = (breedId: string, signal?: AbortSignal) => {
  return customInstance<GetBreedsBreedId200>({
    url: `/breeds/${breedId}`,
    method: "get",
    signal,
  });
};

export const getGetBreedsBreedIdQueryKey = (breedId: string) => {
  return [`/breeds/${breedId}`] as const;
};

export const getGetBreedsBreedIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getBreedsBreedId>>,
  TError = ErrorType<unknown>,
>(
  breedId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBreedsBreedId>>, TError, TData>>;
  }
) => {
  const {query: queryOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBreedsBreedIdQueryKey(breedId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBreedsBreedId>>> = ({signal}) =>
    getBreedsBreedId(breedId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!breedId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getBreedsBreedId>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetBreedsBreedIdQueryResult = NonNullable<Awaited<ReturnType<typeof getBreedsBreedId>>>;
export type GetBreedsBreedIdQueryError = ErrorType<unknown>;

/**
 * @summary /breeds/:breed_id
 */
export const useGetBreedsBreedId = <
  TData = Awaited<ReturnType<typeof getBreedsBreedId>>,
  TError = ErrorType<unknown>,
>(
  breedId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBreedsBreedId>>, TError, TData>>;
  }
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetBreedsBreedIdQueryOptions(breedId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get one or more facts about the Species. For more at a time just update the 'limit' field, and to paginate through them just increment the 'page' field.

The response headers have the pagination details, such as how many there are in total, what page you're on, and the current amount per page.

To redorder change the order to ASC for ascending order, DESC for descending, and RAND for random order.
 * @summary Get Ordered Fact(s) About Breed
 */
export const getBreedsBreedIdFacts = (
  breedId: string,
  params?: GetBreedsBreedIdFactsParams,
  signal?: AbortSignal
) => {
  return customInstance<GetBreedsBreedIdFacts200>({
    url: `/breeds/${breedId}/facts`,
    method: "get",
    params,
    signal,
  });
};

export const getGetBreedsBreedIdFactsQueryKey = (
  breedId: string,
  params?: GetBreedsBreedIdFactsParams
) => {
  return [`/breeds/${breedId}/facts`, ...(params ? [params] : [])] as const;
};

export const getGetBreedsBreedIdFactsQueryOptions = <
  TData = Awaited<ReturnType<typeof getBreedsBreedIdFacts>>,
  TError = ErrorType<unknown>,
>(
  breedId: string,
  params?: GetBreedsBreedIdFactsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBreedsBreedIdFacts>>, TError, TData>
    >;
  }
) => {
  const {query: queryOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBreedsBreedIdFactsQueryKey(breedId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBreedsBreedIdFacts>>> = ({signal}) =>
    getBreedsBreedIdFacts(breedId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!breedId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getBreedsBreedIdFacts>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetBreedsBreedIdFactsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBreedsBreedIdFacts>>
>;
export type GetBreedsBreedIdFactsQueryError = ErrorType<unknown>;

/**
 * @summary Get Ordered Fact(s) About Breed
 */
export const useGetBreedsBreedIdFacts = <
  TData = Awaited<ReturnType<typeof getBreedsBreedIdFacts>>,
  TError = ErrorType<unknown>,
>(
  breedId: string,
  params?: GetBreedsBreedIdFactsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBreedsBreedIdFacts>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetBreedsBreedIdFactsQueryOptions(breedId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Search Breeds
 */
export const getBreedsSearch = (params?: GetBreedsSearchParams, signal?: AbortSignal) => {
  return customInstance<GetBreedsSearch200>({
    url: `/breeds/search`,
    method: "get",
    params,
    signal,
  });
};

export const getGetBreedsSearchQueryKey = (params?: GetBreedsSearchParams) => {
  return [`/breeds/search`, ...(params ? [params] : [])] as const;
};

export const getGetBreedsSearchQueryOptions = <
  TData = Awaited<ReturnType<typeof getBreedsSearch>>,
  TError = ErrorType<unknown>,
>(
  params?: GetBreedsSearchParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBreedsSearch>>, TError, TData>>;
  }
) => {
  const {query: queryOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBreedsSearchQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBreedsSearch>>> = ({signal}) =>
    getBreedsSearch(params, signal);

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getBreedsSearch>>,
    TError,
    TData
  > & {queryKey: QueryKey};
};

export type GetBreedsSearchQueryResult = NonNullable<Awaited<ReturnType<typeof getBreedsSearch>>>;
export type GetBreedsSearchQueryError = ErrorType<unknown>;

/**
 * @summary Search Breeds
 */
export const useGetBreedsSearch = <
  TData = Awaited<ReturnType<typeof getBreedsSearch>>,
  TError = ErrorType<unknown>,
>(
  params?: GetBreedsSearchParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBreedsSearch>>, TError, TData>>;
  }
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetBreedsSearchQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary /favourites
 */
export const getFavourites = (signal?: AbortSignal) => {
  return customInstance<GetFavourites200>({
    url: `/favourites`,
    method: "get",
    signal,
  });
};

export const getGetFavouritesQueryKey = () => {
  return [`/favourites`] as const;
};

export const getGetFavouritesQueryOptions = <
  TData = Awaited<ReturnType<typeof getFavourites>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFavourites>>, TError, TData>>;
}) => {
  const {query: queryOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFavouritesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFavourites>>> = ({signal}) =>
    getFavourites(signal);

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getFavourites>>,
    TError,
    TData
  > & {queryKey: QueryKey};
};

export type GetFavouritesQueryResult = NonNullable<Awaited<ReturnType<typeof getFavourites>>>;
export type GetFavouritesQueryError = ErrorType<unknown>;

/**
 * @summary /favourites
 */
export const useGetFavourites = <
  TData = Awaited<ReturnType<typeof getFavourites>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFavourites>>, TError, TData>>;
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetFavouritesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary /favourites
 */
export const postFavourites = (postFavouritesBody: BodyType<PostFavouritesBody>) => {
  return customInstance<PostFavourites200>({
    url: `/favourites`,
    method: "post",
    headers: {"Content-Type": "application/json"},
    data: postFavouritesBody,
  });
};

export const getPostFavouritesMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postFavourites>>,
    TError,
    {data: BodyType<PostFavouritesBody>},
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postFavourites>>,
  TError,
  {data: BodyType<PostFavouritesBody>},
  TContext
> => {
  const {mutation: mutationOptions} = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postFavourites>>,
    {data: BodyType<PostFavouritesBody>}
  > = (props) => {
    const {data} = props ?? {};

    return postFavourites(data);
  };

  return {mutationFn, ...mutationOptions};
};

export type PostFavouritesMutationResult = NonNullable<Awaited<ReturnType<typeof postFavourites>>>;
export type PostFavouritesMutationBody = BodyType<PostFavouritesBody>;
export type PostFavouritesMutationError = ErrorType<unknown>;

/**
 * @summary /favourites
 */
export const usePostFavourites = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postFavourites>>,
    TError,
    {data: BodyType<PostFavouritesBody>},
    TContext
  >;
}) => {
  const mutationOptions = getPostFavouritesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary /favourites/:favourite_id
 */
export const getFavouritesFavouriteId = (favouriteId: string, signal?: AbortSignal) => {
  return customInstance<unknown>({
    url: `/favourites/${favouriteId}`,
    method: "get",
    signal,
  });
};

export const getGetFavouritesFavouriteIdQueryKey = (favouriteId: string) => {
  return [`/favourites/${favouriteId}`] as const;
};

export const getGetFavouritesFavouriteIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getFavouritesFavouriteId>>,
  TError = ErrorType<unknown>,
>(
  favouriteId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFavouritesFavouriteId>>, TError, TData>
    >;
  }
) => {
  const {query: queryOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFavouritesFavouriteIdQueryKey(favouriteId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFavouritesFavouriteId>>> = ({signal}) =>
    getFavouritesFavouriteId(favouriteId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!favouriteId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getFavouritesFavouriteId>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetFavouritesFavouriteIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFavouritesFavouriteId>>
>;
export type GetFavouritesFavouriteIdQueryError = ErrorType<unknown>;

/**
 * @summary /favourites/:favourite_id
 */
export const useGetFavouritesFavouriteId = <
  TData = Awaited<ReturnType<typeof getFavouritesFavouriteId>>,
  TError = ErrorType<unknown>,
>(
  favouriteId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFavouritesFavouriteId>>, TError, TData>
    >;
  }
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetFavouritesFavouriteIdQueryOptions(favouriteId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary /favourites/:favourite_id
 */
export const deleteFavouritesFavouriteId = (favouriteId: string) => {
  return customInstance<unknown>({
    url: `/favourites/${favouriteId}`,
    method: "delete",
  });
};

export const getDeleteFavouritesFavouriteIdMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteFavouritesFavouriteId>>,
    TError,
    {favouriteId: string},
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteFavouritesFavouriteId>>,
  TError,
  {favouriteId: string},
  TContext
> => {
  const {mutation: mutationOptions} = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteFavouritesFavouriteId>>,
    {favouriteId: string}
  > = (props) => {
    const {favouriteId} = props ?? {};

    return deleteFavouritesFavouriteId(favouriteId);
  };

  return {mutationFn, ...mutationOptions};
};

export type DeleteFavouritesFavouriteIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteFavouritesFavouriteId>>
>;

export type DeleteFavouritesFavouriteIdMutationError = ErrorType<unknown>;

/**
 * @summary /favourites/:favourite_id
 */
export const useDeleteFavouritesFavouriteId = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteFavouritesFavouriteId>>,
    TError,
    {favouriteId: string},
    TContext
  >;
}) => {
  const mutationOptions = getDeleteFavouritesFavouriteIdMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary /votes
 */
export const getVotes = (signal?: AbortSignal) => {
  return customInstance<GetVotes200>({url: `/votes`, method: "get", signal});
};

export const getGetVotesQueryKey = () => {
  return [`/votes`] as const;
};

export const getGetVotesQueryOptions = <
  TData = Awaited<ReturnType<typeof getVotes>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getVotes>>, TError, TData>>;
}) => {
  const {query: queryOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVotesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVotes>>> = ({signal}) =>
    getVotes(signal);

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getVotes>>,
    TError,
    TData
  > & {queryKey: QueryKey};
};

export type GetVotesQueryResult = NonNullable<Awaited<ReturnType<typeof getVotes>>>;
export type GetVotesQueryError = ErrorType<unknown>;

/**
 * @summary /votes
 */
export const useGetVotes = <
  TData = Awaited<ReturnType<typeof getVotes>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getVotes>>, TError, TData>>;
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetVotesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary /votes
 */
export const postVotes = (postVotesBody: BodyType<PostVotesBody>) => {
  return customInstance<PostVotes201>({
    url: `/votes`,
    method: "post",
    headers: {"Content-Type": "application/json"},
    data: postVotesBody,
  });
};

export const getPostVotesMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postVotes>>,
    TError,
    {data: BodyType<PostVotesBody>},
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postVotes>>,
  TError,
  {data: BodyType<PostVotesBody>},
  TContext
> => {
  const {mutation: mutationOptions} = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postVotes>>,
    {data: BodyType<PostVotesBody>}
  > = (props) => {
    const {data} = props ?? {};

    return postVotes(data);
  };

  return {mutationFn, ...mutationOptions};
};

export type PostVotesMutationResult = NonNullable<Awaited<ReturnType<typeof postVotes>>>;
export type PostVotesMutationBody = BodyType<PostVotesBody>;
export type PostVotesMutationError = ErrorType<unknown>;

/**
 * @summary /votes
 */
export const usePostVotes = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postVotes>>,
    TError,
    {data: BodyType<PostVotesBody>},
    TContext
  >;
}) => {
  const mutationOptions = getPostVotesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary /votes/:vote_id
 */
export const getVotesVoteId = (voteId: string, signal?: AbortSignal) => {
  return customInstance<unknown>({
    url: `/votes/${voteId}`,
    method: "get",
    signal,
  });
};

export const getGetVotesVoteIdQueryKey = (voteId: string) => {
  return [`/votes/${voteId}`] as const;
};

export const getGetVotesVoteIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getVotesVoteId>>,
  TError = ErrorType<unknown>,
>(
  voteId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getVotesVoteId>>, TError, TData>>;
  }
) => {
  const {query: queryOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVotesVoteIdQueryKey(voteId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVotesVoteId>>> = ({signal}) =>
    getVotesVoteId(voteId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!voteId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getVotesVoteId>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetVotesVoteIdQueryResult = NonNullable<Awaited<ReturnType<typeof getVotesVoteId>>>;
export type GetVotesVoteIdQueryError = ErrorType<unknown>;

/**
 * @summary /votes/:vote_id
 */
export const useGetVotesVoteId = <
  TData = Awaited<ReturnType<typeof getVotesVoteId>>,
  TError = ErrorType<unknown>,
>(
  voteId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getVotesVoteId>>, TError, TData>>;
  }
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetVotesVoteIdQueryOptions(voteId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary /votes/:vote_id
 */
export const deleteVoteVoteId = (voteId: string) => {
  return customInstance<unknown>({url: `/vote/${voteId}`, method: "delete"});
};

export const getDeleteVoteVoteIdMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteVoteVoteId>>,
    TError,
    {voteId: string},
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteVoteVoteId>>,
  TError,
  {voteId: string},
  TContext
> => {
  const {mutation: mutationOptions} = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteVoteVoteId>>,
    {voteId: string}
  > = (props) => {
    const {voteId} = props ?? {};

    return deleteVoteVoteId(voteId);
  };

  return {mutationFn, ...mutationOptions};
};

export type DeleteVoteVoteIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteVoteVoteId>>
>;

export type DeleteVoteVoteIdMutationError = ErrorType<unknown>;

/**
 * @summary /votes/:vote_id
 */
export const useDeleteVoteVoteId = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteVoteVoteId>>,
    TError,
    {voteId: string},
    TContext
  >;
}) => {
  const mutationOptions = getDeleteVoteVoteIdMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Create Webhook
 */
export const postWebhooks = (postWebhooksBody: BodyType<PostWebhooksBody>) => {
  return customInstance<PostWebhooks200>({
    url: `/webhooks`,
    method: "post",
    headers: {"Content-Type": "application/json"},
    data: postWebhooksBody,
  });
};

export const getPostWebhooksMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postWebhooks>>,
    TError,
    {data: BodyType<PostWebhooksBody>},
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postWebhooks>>,
  TError,
  {data: BodyType<PostWebhooksBody>},
  TContext
> => {
  const {mutation: mutationOptions} = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postWebhooks>>,
    {data: BodyType<PostWebhooksBody>}
  > = (props) => {
    const {data} = props ?? {};

    return postWebhooks(data);
  };

  return {mutationFn, ...mutationOptions};
};

export type PostWebhooksMutationResult = NonNullable<Awaited<ReturnType<typeof postWebhooks>>>;
export type PostWebhooksMutationBody = BodyType<PostWebhooksBody>;
export type PostWebhooksMutationError = ErrorType<unknown>;

/**
 * @summary Create Webhook
 */
export const usePostWebhooks = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postWebhooks>>,
    TError,
    {data: BodyType<PostWebhooksBody>},
    TContext
  >;
}) => {
  const mutationOptions = getPostWebhooksMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get one or more Random facts and the Species. For more at a time just update the 'limit' field
 * @summary Get Random Fact(s)
 */
export const getFacts = (signal?: AbortSignal) => {
  return customInstance<GetFacts200>({url: `/facts`, method: "get", signal});
};

export const getGetFactsQueryKey = () => {
  return [`/facts`] as const;
};

export const getGetFactsQueryOptions = <
  TData = Awaited<ReturnType<typeof getFacts>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFacts>>, TError, TData>>;
}) => {
  const {query: queryOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFactsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFacts>>> = ({signal}) =>
    getFacts(signal);

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getFacts>>,
    TError,
    TData
  > & {queryKey: QueryKey};
};

export type GetFactsQueryResult = NonNullable<Awaited<ReturnType<typeof getFacts>>>;
export type GetFactsQueryError = ErrorType<unknown>;

/**
 * @summary Get Random Fact(s)
 */
export const useGetFacts = <
  TData = Awaited<ReturnType<typeof getFacts>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFacts>>, TError, TData>>;
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetFactsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};
